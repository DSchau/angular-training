doctype html
include ../includes/mixins

+page("Lecture 06 - Promises and Interceptors")
  +lecture-title-page("Promises and Interceptors", "Lecture 06")

  section
    h1 Lab 05
    h2 Solution

  section
    h1 Promises

  section
    p
      | Promises provide a well-defined interface for interacting with an object that represents the result
      | of an asynchronous action.

  section
    p That action may or may not be finished at any given point in time.

  section
    img.no-style(style="width: 75%;", src="/assets/img/lecture-06/wat_grande.jpg")

  section
    p To understand why we use promises, lets look at one big problem that promises can mitigate.

  section
    h3 The
    h1 Pyramid
    h1 of Doom

  section
    p The "Pyramid of Doom" a situation where code marches to the right faster than it marches forward.
    br
    pre.
      <code class="js" data-trim>
      step1(function (value1) {
        step2(value1, function(value2) {
          step3(value2, function(value3) {
            step4(value3, function(value4) {
              step5(value4, function(value5) {
                step6(value5, function(value6) {
                  // Do something with value6
                });
              });
            });
          });
        });
      });

      </code>

  section
    p We also call this "callback hell" because we're nesting a callback, within a callback, within a callback to perform a sequence of tasks.
    br
    pre.
      <code class="js" data-trim>
      // step1() executes a callback when it's finished
      // and supplies the result
      step1(function (value1) {
        // step2() uses the result from step1(),
        // does something with it,
        // and executes a callback with it's result when it's done.
        step2(value1, function(value2) {
          // please, make it stop...
        });
      });

      </code>

  section
    p With a promise library, you can flatten the pyramid.
    br
    pre.
      <code class="js" data-trim>
      promisedStep1()
        .then(promisedStep2)
        .then(promisedStep3)
        .then(promisedStep4)
        .then(promisedStep5)
        .then(promisedStep6)
        .then(function (value6) {
          // Do something with value6
        })
        .catch(function (error) {
          // Handle any error from all above steps
        })
        .done();

      </code>

  section
    p With this approach, you also get implicit error propagation, just like try, catch, and finally.

  section
    p An error in promisedStep1 will flow all the way to the catch function, where itâ€™s caught and handled.

  section
    p Using the callback method, you would have to provide error handling for each individual step.

  section
    p AngularJS provides the $q service which you can use to create your own promises.

  section
    p Our original definition of a promise was:
    p
      | Promises provide a well-defined interface for interacting with an object that represents the result
      | of an asynchronous action.

  section
    p What do we use as the "object that represents the result of an asynchronous action"?

  section
    h3 Deferred
    p The "Deferred" object represents a task which will finish in the future.

  section
    p AngularJS provides the $q service which you can use to create deferreds and chain promises.

  section
    p Let's create a promise chain with the $q service.

  section
    p First, lets create an asyncronous function that returns a promise for a result.
    br
    pre.
      <code class="js" data-trim>
      controller('PromiseCtrl', function($scope, $q, $timeout) {
        $scope.myAsyncTask = function() {
          // Create the deferred object
          var deferred = $q.defer();

          // After 2 seconds
          $timeout(function() {
            // Fulfill the promise with a result
            deferred.resolve("My Result");
          }, 2000);

          // Return the promise for a result immediately
          // This function returns before we resolve the promise
          return deferred.promise;
        };
      });

      </code>

  section
    p Now, lets use the promise to execute a task after our asyncronous function completes.
    br
    pre.
      <code class="js" data-trim>
      controller('PromiseCtrl', function($scope, $q, $timeout) {

        // $scope.myAsyncTask = ...

        $scope.myAsyncTask()         // call myAsyncTask
          .then(function(result) {   // then,
            $scope.result = result;  // save the result on scope
          });

      });

      </code>

  section
    p You've seen this before...

  section
    p The $control service methods return promises to the response data from the server.
    br
    pre.
      <code class="js" data-trim>
      controller('EmployeeCtrl', function($scope, $q, $timeout) {

        $control.list('employees')
          .then(function (employees) {
            $scope.employees = employees;
          });

      });

      </code>

  section
    p  In this lab, you'll use a promise for an authenticated user with AngularUI Router to implement client side security.

  section
    h1 Interceptors

  section


  section


  section


  section


  section


  section


  section


  section


  section


  section


  section


  section

  section


  section


  section


  section


  section


  section


  section


  section


  section


  section
